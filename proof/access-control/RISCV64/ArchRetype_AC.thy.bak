(*
 * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
 *
 * SPDX-License-Identifier: GPL-2.0-only
 *)

theory ArchRetype_AC
imports Retype_AC
begin


lemma invs_mdb_cte':
  "invs s \<Longrightarrow> mdb_cte_at (\<lambda>p. \<exists>c. caps_of_state s p = Some c \<and> NullCap \<noteq> c) (cdt s)"
  by (drule invs_mdb) (simp add: valid_mdb_def2)


context retype_region_proofs begin interpretation Arch .

lemma pts_of:
  "pts_of s p = pts_of s' p"
apply (rule option.expand)
apply (rule iffI)
  apply (clarsimp simp: in_opt_map_eq s'_def ps_def opt_map_def)
   apply  (erule pspace_no_overlapC [OF orth _ _ cover vp])
apply (clarsimp split: option.splits)

apply (cases "pts_of s p")
find_theorems intro name: option
prefer 2
  apply (clarsimp simp: in_opt_map_eq s'_def ps_def)
   apply  (erule pspace_no_overlapC [OF orth _ _ cover vp])
oops


lemma orthr_alt:
   "x \<in> set (retype_addrs ptr ty n us) \<Longrightarrow> kheap s x = None"
  using orthr
  by (meson not_None_eq)

lemma vs_lookup_table_eqI:
"arch_state s = arch_state s' \<Longrightarrow>
vs_lookup_table bot_level asid vptr s = vs_lookup_table bot_level asid vptr s'"
supply pt_walk.simps[simp del]
  apply (simp only: vs_lookup_table_def)
  apply simp
apply (simp add: vs_lookup_table_def in_omonad opt_map_def split: if_splits)
apply (auto simp: obind_def)
apply (prop_tac "pool_for_asid asid s = pool_for_asid asid s'")
apply (clarsimp simp: pool_for_asid_def)
apply (case_tac "pool_for_asid asid s'")
apply clarsimp
apply (clarsimp simp: s'_def ps_def)
apply (prop_tac "ty \<noteq> ArchObject ASIDPoolObj")
subgoal sorry

apply (clarsimp simp: vspace_for_pool_def obind_def)
apply (intro conjI)
apply clarsimp
apply (frule orthr_alt)
apply clarsimp
apply (clarsimp simp: default_object_def )
apply (prop_tac "ty \<noteq> Untyped")
apply (simp add: tyunt)
apply (case_tac ty; clarsimp)
apply (clarsimp simp: default_arch_object_def split: aobject_type.splits)

apply clarsimp
apply (case_tac "kheap s a"; clarsimp)
apply (case_tac "aobj_of aa"; clarsimp)
apply (case_tac "asid_pool_of ab"; clarsimp)
apply (case_tac "aa (asid_low_bits_of asid)"; clarsimp)

apply (simp add: pte_of_def obind_def)

oops

thm pt_walk_level




lemma "pt_walk top_level bot_level pt vptr f = X"
supply pt_walk.simps[simp del]
 apply (subst pt_walk.simps)
apply (simp add: obind_def)

lemma "pt_walk top_level bot_level pt vptr
             (\<lambda>p. case if is_aligned p pte_bits then Some () else None of None \<Rightarrow> None
                   | Some x \<Rightarrow>
                       case case case if table_base p \<in> set (retype_addrs ptr ty n us) then Some (default_object ty dev us) else kheap s (table_base p) of
                                 None \<Rightarrow> None | Some x2 \<Rightarrow> aobj_of x2 of
                            None \<Rightarrow> None | Some x2 \<Rightarrow> pt_of x2 of
                       None \<Rightarrow> None | Some x \<Rightarrow> Some (x (table_index p))) =
pt_walk top_level bot_level pt vptr
             (\<lambda>p. case if is_aligned p pte_bits then Some () else None of None \<Rightarrow> None
                   | Some x \<Rightarrow>
                       case case case kheap s (table_base p) of
                                 None \<Rightarrow> None | Some x2 \<Rightarrow> aobj_of x2 of
                            None \<Rightarrow> None | Some x2 \<Rightarrow> pt_of x2 of
                       None \<Rightarrow> None | Some x \<Rightarrow> Some (x (table_index p)))"
  apply (induct top_level arbitrary: pt)
   apply simp
 apply (subst pt_walk.simps)
 apply (subst pt_walk.simps) back
  apply (case_tac "bot_level < top_level"; clarsimp)
apply (clarsimp simp: obind_def split del: if_split)
apply clarsimp
(* same as pte_at (pt_slot_offset top_level pt vptr) *)
thm vs_lookup_slot_pte_at
apply (prop_tac "kheap s (table_base (pt_slot_offset top_level pt vptr)) \<noteq> None")
subgoal sorry
apply (rule conjI; clarsimp)
apply (frule orthr_alt)
apply clarsimp
apply (case_tac "aobj_of y"; clarsimp)
apply (case_tac "pt_of a"; clarsimp)
done

term valid_arch_state

 (*

  apply (clarsimp simp: in_omonad split: if_splits)
   prefer 2
   apply (subst pt_walk.simps)
   apply (simp add: in_omonad)
  apply (erule disjE; clarsimp)
   prefer 2
   apply (subst pt_walk.simps)
   apply (simp add: in_omonad)
   apply (rule_tac x=v' in exI)
   apply (simp add: ptes_of)
  apply (drule ptes_of)
  apply (subst pt_walk.simps)
  apply (simp add: in_omonad)
  done
*)

lemma pt_walk:
  "pt_walk top_level bot_level pt vref (ptes_of s') = Some (level, p) \<Longrightarrow>
   pt_walk top_level bot_level pt vref (ptes_of s) = Some (level, p)"
  apply (induct top_level arbitrary: pt)
   apply simp
  apply (subst (asm) (3) pt_walk.simps)
  apply (clarsimp simp: in_omonad split: if_splits)
   prefer 2
   apply (subst pt_walk.simps)
   apply (simp add: in_omonad)
  apply (erule disjE; clarsimp)
   prefer 2
   apply (subst pt_walk.simps)
   apply (simp add: in_omonad)
   apply (rule_tac x=v' in exI)
   apply (simp add: ptes_of)
  apply (drule ptes_of)
  apply (subst pt_walk.simps)
  apply (simp add: in_omonad)
  done


thm pt_walk_split_Some
thm pt_walk_max_level
thm pt_walk_stopped
thm vs_lookup_table_stopped


lemma valid_vs_lookup:
  "valid_vs_lookup s \<Longrightarrow> valid_vs_lookup s'"
  unfolding valid_vs_lookup_def
  apply clarsimp
  apply (drule vs_lookup_target_level)
  by (fastforce simp: vs_lookup_target' intro: caps_of_state')

(*
locale retype_region_proofs =
  fixes s :: "'state_ext :: state_ext state"
    and ty us ptr sz n ps s' dev
  assumes    vp: "valid_pspace s"
      and    vm: "valid_mdb s"
      and   res: "caps_overlap_reserved {ptr..ptr + of_nat (n * 2 ^ (obj_bits_api ty us)) - 1} s"
      and tyunt: "ty \<noteq> Structures_A.apiobject_type.Untyped"
      and  tyct: "ty = CapTableObject \<Longrightarrow> us < word_bits - cte_level_bits \<and> 0 < us"
      and   orth: "pspace_no_overlap_range_cover ptr sz s"
      and  mem :  "caps_no_overlap ptr sz s"
      and cover: "range_cover ptr sz (obj_bits_api ty us) n"
      and dev: "\<exists>slot. cte_wp_at (\<lambda>c.  {ptr..(ptr && ~~ mask sz) + (2 ^ sz - 1)} \<subseteq> cap_range c \<and> cap_is_device c = dev) slot s"
  defines "ps \<equiv> (\<lambda>x. if x \<in> set (retype_addrs ptr ty n us) then Some (default_object ty dev us)
                       else kheap s x)"
      and "s' \<equiv> kheap_update (\<lambda>y. ps) s"
*)

term retype_region_proofs
term caps_no_overlap
term dev
term cap_is_device
term arch_cap_is_device

lemma vrefs_eq: "state_vrefs s' = state_vrefs s"
apply (simp add: state_vrefs_def)
apply (simp add: s'_def ps_def)
oops




lemma "\<lbrakk> valid_arch_state s; valid_vspace_objs s \<rbrakk> \<Longrightarrow>
         x \<in> state_vrefs s' ptr \<Longrightarrow>
         x \<in> state_vrefs s ptr"
  apply (insert dev vp)
  apply (clarsimp simp: state_vrefs_def)
  apply (frule vs_lookup_level)
  apply (simp add: vs_lookup_table')
  apply (prop_tac "kheap s ptr = kheap s' ptr")
   apply (clarsimp simp: s'_def ps_def split: if_splits)
   apply (case_tac "lvl > max_pt_level")
    apply (fastforce simp: valid_arch_state_def opt_map_def orthr
                     dest: vs_lookup_asid_pool
                    split: option.splits)
   apply (fastforce simp: valid_arch_state_def valid_pspace_def obj_at_def orthr
                   dest!: vs_lookup_table_pt_at )
  apply (fastforce simp: opt_map_def)
  done

lemma state_vrefs_eq:
  "\<lbrakk> valid_vspace_objs s; valid_arch_state s \<rbrakk>
     \<Longrightarrow> state_vrefs s' = state_vrefs s"
  apply (insert dev vp)
  apply (intro ext subset_antisym subsetI)
   apply (clarsimp simp: state_vrefs_def)
   apply (frule vs_lookup_level)
   apply (simp add: vs_lookup_table')
   apply (prop_tac "kheap s x = kheap s' x")
    apply (clarsimp simp: s'_def ps_def split: if_splits)
    apply (case_tac "lvl > max_pt_level")
     apply (fastforce simp: valid_arch_state_def opt_map_def orthr
                      dest: vs_lookup_asid_pool
                     split: option.splits)
    apply (fastforce simp: valid_arch_state_def valid_pspace_def obj_at_def orthr
                    dest!: vs_lookup_table_pt_at )
   apply (fastforce simp: opt_map_def)
  apply (clarsimp simp: state_vrefs_def)
  apply (frule vs_lookup_level)
  apply (prop_tac "kheap s x = kheap s' x")
   apply (clarsimp simp: s'_def ps_def split: if_splits)
   apply (case_tac "lvl > max_pt_level")
    apply (fastforce simp: valid_arch_state_def opt_map_def orthr
                     dest: vs_lookup_asid_pool
                    split: option.splits)
   apply (fastforce simp: valid_arch_state_def valid_pspace_def obj_at_def orthr
                   dest!: vs_lookup_table_pt_at )
  apply (fastforce simp: opt_map_def vs_lookup_table'[symmetric])
  done






lemma "x \<in> state_vrefs s' ptr \<Longrightarrow>
       x \<in> state_vrefs s ptr"

apply (insert dev)
apply (clarsimp)
apply (drule cte_wp_at_eqD)
apply clarsimp



apply (clarsimp simp: state_vrefs_def)
apply (simp only: s'_def ps_def)

apply (clarsimp simp: opt_map_def split: option.splits)

apply (clarsimp split: if_splits)
apply (simp add: orthr_alt)

apply (case_tac "lvl > max_pt_level")
apply clarsimp
apply (drule vs_lookup_asid_pool)
subgoal sorry (* doable *)
apply (clarsimp simp: opt_map_def)
subgoal sorry
subgoal sorry

apply (frule vs_lookup_min_level)

apply (case_tac "bot = lvl")
apply clarsimp
apply (subst (asm) retype_region_proofs.vs_lookup_table')
subgoal sorry (* doable *)
apply (rule_tac x="vs_refs_aux lvl ao" in exI)
apply (rule conjI)
apply (rule_tac x=lvl in exI)
apply (rule_tac x=ao in exI)
apply fastforce
apply simp

apply (drule vs_lookup_level)
apply (subst (asm) retype_region_proofs.vs_lookup_table')
subgoal sorry (* doable *)
apply (rule_tac x="vs_refs_aux lvl ao" in exI)
apply (rule conjI)
apply (rule_tac x=lvl in exI)
apply (rule_tac x=ao in exI)
apply fastforce
apply simp
done


thm ccontr
apply (clarsimp simp: orthr)
apply (simp add: default_object_def)

apply (rule context_conjI; clarsimp?)
oops

lemma vrefs_eq: "state_vrefs s' = state_vrefs s"
apply (rule state_vrefs_eqI)
apply simp
apply (intro conjI impI allI)
apply (simp only: s'_def ps_def)
apply(auto simp: opt_map_def)[1]
find_theorems intro
thm retype_region_proofs.pts_of
oops

term retype_region_proofs
lemma vrefs_eq: "state_vrefs s' = state_vrefs s"
apply (rule ext)
apply (simp add: state_vrefs_def)
  apply (simp add: s'_def state_vrefs_def ps_def orthr  split: option.split)
apply (clarsimp simp: opt_map_def)
apply (subst retype_region_proofs.vs_lookup_table')
apply_trace safe

apply (simp add: vs_lookup_table_def in_omonad opt_map_def split: if_splits)


thm vs_lookup_table'
apply (subst (asm) vs_lookup_table')
apply (clarsimp simp: retype_region_proofs.vs_lookup_table'[simplified fun_upd_def])
apply (auto)
thm orthr
apply (auto simp: opt_map_def aobj_of_def default_object_def is_cap_simps)
  oops


end


context retype_region_proofs' begin interpretation Arch .

lemma pas_refined:
  "\<lbrakk> invs s; pas_refined aag s \<rbrakk> \<Longrightarrow> pas_refined aag s'"
  apply (erule pas_refined_state_objs_to_policy_subset)
     apply (simp add: state_objs_to_policy_def refs_eq vrefs_eq mdb_and_revokable)
     apply (rule subsetI, rename_tac x, case_tac x, simp)
     apply (erule state_bits_to_policy.cases)
            apply (solves \<open>auto intro!: sbta_caps intro: caps_retype split: cap.split\<close>)
           apply (solves \<open>auto intro!: sbta_untyped intro: caps_retype split: cap.split\<close>)
          apply (blast intro: state_bits_to_policy.intros)
         apply (blast intro: state_bits_to_policy.intros)
        apply (force intro!: sbta_cdt
                       dest: caps_of_state_pres invs_mdb_cte'[THEN mdb_cte_atD[rotated]])
       apply (force intro!: sbta_cdt_transferable
                      dest: caps_of_state_pres invs_mdb_cte'[THEN mdb_cte_atD[rotated]])
      apply (simp add: vrefs_eq)
      apply (blast intro: state_bits_to_policy.intros)
     apply (simp add: vrefs_eq)
     apply (force elim!: state_asids_to_policy_aux.cases
                 intro: state_asids_to_policy_aux.intros caps_retype
                 split: cap.split
                 dest: sata_asid[OF caps_retype, rotated])
    apply clarsimp
    apply (erule state_irqs_to_policy_aux.cases)
    apply (solves\<open>auto intro!: sita_controlled intro: caps_retype split: cap.split\<close>)
   apply (rule domains_of_state)
  apply simp
  done

end


context Arch begin global_naming ARM_A

named_theorems Retype_AC_assms

declare retype_region_proofs.vrefs_eq[Retype_AC_assms]
declare retype_region_proofs'.pas_refined[Retype_AC_assms]

crunch integrity_autarch: set_pd "integrity aag X st"
  (wp: crunch_wps simp: crunch_simps)


lemma state_vrefs_detype[Retype_AC_assms,simp]:
  "state_vrefs (detype R s) = (\<lambda>x. if x \<in> R then {} else state_vrefs s x)"
  apply (rule ext)
  apply (case_tac "x \<in> R"; clarsimp)
  apply (clarsimp simp: state_vrefs_def)
  apply (auto split: if_splits)
  apply (clarsimp simp: detype_def)
  sorry

lemma sata_detype[Retype_AC_assms]:
  "state_asids_to_policy aag (detype R s) \<subseteq> state_asids_to_policy aag s"
  apply (clarsimp)
  apply (erule state_asids_to_policy_aux.induct)
  apply (auto intro: state_asids_to_policy_aux.intros split: if_split_asm)
  done

lemma untyped_min_bits_ge_2[Retype_AC_assms]: "2 \<le> untyped_min_bits"
  by (simp add: untyped_min_bits_def)

lemma clas_default_cap[Retype_AC_assms]:
  "tp \<noteq> ArchObject ASIDPoolObj \<Longrightarrow> cap_links_asid_slot aag p (default_cap tp p' sz dev)"
  unfolding cap_links_asid_slot_def
  apply (cases tp, simp_all)
  apply (rename_tac aobject_type)
  apply (case_tac aobject_type, simp_all add: arch_default_cap_def)
  done

lemma cli_default_cap[Retype_AC_assms]:
  "tp \<noteq> ArchObject ASIDPoolObj \<Longrightarrow> cap_links_irq aag p (default_cap tp p' sz dev)"
  unfolding cap_links_irq_def
  apply (cases tp, simp_all)
  done

lemma aobj_refs'_default'[Retype_AC_assms]:
  "is_aligned oref (obj_bits_api (ArchObject tp) sz)
   \<Longrightarrow> aobj_ref' (arch_default_cap tp oref sz dev) \<subseteq> ptr_range oref (obj_bits_api (ArchObject tp) sz)"
  by (cases tp; simp add: arch_default_cap_def ptr_range_memI obj_bits_api_def default_arch_object_def)


lemma init_arch_objects_inv:
  "\<lbrace>pas_refined aag\<rbrace>
   init_arch_objects tp ptr bits obj_sz refs
   \<lbrace>\<lambda>_. pas_refined aag\<rbrace>"
  by (simp add: init_arch_objects_def)

lemma region_in_kernel_window_preserved:
  assumes "\<And>P. f \<lbrace>\<lambda>s. P (arch_state s)\<rbrace>"
  shows "\<And>S. f \<lbrace>region_in_kernel_window S\<rbrace>"
  apply (clarsimp simp: valid_def region_in_kernel_window_def)
  apply (erule use_valid)
  apply (rule assms)
  apply fastforce
  done

(* proof clagged from Retype_AI.clearMemory_vms *)
lemma freeMemory_vms:
  "valid_machine_state s \<Longrightarrow>
   \<forall>x\<in>fst (freeMemory ptr bits (machine_state s)). valid_machine_state (s\<lparr>machine_state := snd x\<rparr>)"
  apply (clarsimp simp: valid_machine_state_def disj_commute[of "in_user_frame p s" for p s])
  apply (drule_tac x=p in spec, simp)
  apply (drule_tac P4="\<lambda>m'. underlying_memory m' p = 0"
                in use_valid[where P=P and Q="\<lambda>_. P" for P], simp_all)
  apply (simp add: freeMemory_def machine_op_lift_def machine_rest_lift_def split_def)
  apply (wp hoare_drop_imps | simp | wp mapM_x_wp_inv)+
   apply (simp add: storeWord_def | wp)+
   apply (simp add: word_rsplit_0)+
  done

lemma dmo_freeMemory_vms:
  "do_machine_op (freeMemory ptr bits) \<lbrace>valid_machine_state\<rbrace>"
  apply (unfold do_machine_op_def)
  apply (wp modify_wp freeMemory_vms | simp add: split_def)+
  done

lemma freeMemory_valid_irq_states:
  "freeMemory ptr bits \<lbrace>\<lambda>ms. valid_irq_states (s\<lparr>machine_state := ms\<rparr>)\<rbrace>"
  unfolding freeMemory_def
  by (wp mapM_x_wp[OF _ subset_refl] storeWord_valid_irq_states)

crunch pspace_respects_device_region[wp]: freeMemory "\<lambda>ms. P (device_state ms)"
  (wp: crunch_wps)

lemma dmo_freeMemory_invs[Retype_AC_assms]:
  "do_machine_op (freeMemory ptr bits) \<lbrace>invs\<rbrace>"
  apply (simp add: do_machine_op_def invs_def valid_state_def cur_tcb_def | wp | wpc)+
  apply (clarsimp)
  apply (frule_tac P1="(=) (device_state (machine_state s))"
                in use_valid[OF _ freeMemory_pspace_respects_device_region])
   apply simp
  apply simp
  apply (rule conjI)
   apply (erule use_valid[OF _ freeMemory_valid_irq_states], simp)
  apply (drule freeMemory_vms)
  apply auto
  done

crunch global_refs[wp]: delete_objects "\<lambda>s. P (global_refs s)"
  (ignore: do_machine_op freeMemory)

lemma init_arch_objects_pas_cur_domain[Retype_AC_assms, wp]:
  "init_arch_objects tp ptr n us refs \<lbrace>pas_cur_domain aag\<rbrace>"
  by wp

lemma retype_region_pas_cur_domain[Retype_AC_assms, wp]:
  "retype_region ptr n us tp dev \<lbrace>pas_cur_domain aag\<rbrace>"
  by wp

lemma reset_untyped_cap_pas_cur_domain[Retype_AC_assms, wp]:
  "reset_untyped_cap src_slot \<lbrace>pas_cur_domain aag\<rbrace>"
  by wp

lemma arch_data_to_obj_type_not_ASIDPoolObj[Retype_AC_assms, simp]:
  "arch_data_to_obj_type v \<noteq> Some ASIDPoolObj"
  by (clarsimp simp: arch_data_to_obj_type_def)

lemma data_to_nat_of_nat[Retype_AC_assms, simp]:
  "of_nat (data_to_nat x) = x"
  by simp

lemma nonzero_data_to_nat_simp[Retype_AC_assms]:
  "0 < data_to_nat x \<Longrightarrow> 0 < x"
  by (auto dest: word_of_nat_less)

lemma storeWord_integrity_autarch:
  "\<lbrace>\<lambda>ms. integrity aag X st (s\<lparr>machine_state := ms\<rparr>) \<and>
         (is_aligned p 2 \<longrightarrow> (\<forall>p' \<in> ptr_range p 2. is_subject aag p'))\<rbrace>
   storeWord p v
   \<lbrace>\<lambda>_ ms. integrity aag X st (s\<lparr>machine_state := ms\<rparr>)\<rbrace>"
  unfolding storeWord_def
  apply wp
  apply (auto simp: integrity_def is_aligned_mask [symmetric]
            intro!: trm_lrefl ptr_range_memI ptr_range_add_memI)
  done

(* TODO: proof has mainly been copied from dmo_clearMemory_respects *)
lemma dmo_freeMemory_respects[Retype_AC_assms]:
  "\<lbrace>integrity aag X st and K (is_aligned ptr bits \<and> bits < word_bits \<and> 2 \<le> bits \<and>
                              (\<forall>p \<in> ptr_range ptr bits. is_subject aag p))\<rbrace>
   do_machine_op (freeMemory ptr bits)
   \<lbrace>\<lambda>_. integrity aag X st\<rbrace>"
  unfolding do_machine_op_def freeMemory_def
  apply (simp add: split_def)
  apply wp
  apply clarsimp
  apply (erule use_valid)
   apply (wp mol_respects mapM_x_wp' storeWord_integrity_autarch)
   apply simp
   apply (clarsimp simp: word_size_def word_bits_def
                         upto_enum_step_shift_red[where us=2, simplified])
   apply (erule bspec)
   apply (erule set_mp [rotated])
   apply (rule ptr_range_subset)
      apply simp
     apply (simp add: is_aligned_mult_triv2 [where n = 2, simplified])
    apply assumption
   apply (erule word_less_power_trans_ofnat [where k = 2, simplified])
    apply assumption
   apply simp
  apply simp
  done

lemma storeWord_respects:
  "\<lbrace>\<lambda>ms. integrity aag X st (s\<lparr>machine_state := ms\<rparr>) \<and>
         (\<forall>p' \<in> ptr_range p word_size_bits. aag_has_auth_to aag Write p')\<rbrace>
   storeWord p v
   \<lbrace>\<lambda>_ ms. integrity aag X st (s\<lparr>machine_state := ms\<rparr>)\<rbrace>"
  unfolding storeWord_def word_size_bits_def
  apply wp
  apply (auto simp: integrity_def is_aligned_mask [symmetric]
            intro!: trm_write ptr_range_memI ptr_range_add_memI)
  done

lemma dmo_clearMemory_respects'[Retype_AC_assms]:
  "\<lbrace>integrity aag X st and
    K (is_aligned ptr bits \<and> bits < word_bits \<and> 2 \<le> bits \<and>
       (\<forall>p \<in> ptr_range ptr bits. aag_has_auth_to aag Write p))\<rbrace>
   do_machine_op (clearMemory ptr (2 ^ bits))
   \<lbrace>\<lambda>_. integrity aag X st\<rbrace>"
  unfolding do_machine_op_def clearMemory_def
  apply (simp add: split_def cleanCacheRange_PoU_def)
  apply wp
  apply clarsimp
  apply (erule use_valid)
   apply wp
    apply (simp add: cleanByVA_PoU_def)
    apply (wp mol_respects mapM_x_wp' storeWord_respects)+
   apply (simp add: word_size_bits_def)
   apply (clarsimp simp: word_size_def word_bits_def upto_enum_step_shift_red[where us=2, simplified])
   apply (erule bspec)
   apply (erule set_mp [rotated])
   apply (rule ptr_range_subset)
      apply simp
     apply (simp add: is_aligned_mult_triv2 [where n = 2, simplified])
    apply assumption
   apply (erule word_less_power_trans_ofnat [where k = 2, simplified])
    apply assumption
   apply simp
  apply simp
  done

lemma dmo_cacheRangeOp_lift:
  "(\<And>a b. do_machine_op (oper a b) \<lbrace>P\<rbrace>)
   \<Longrightarrow> do_machine_op (cacheRangeOp oper x y z) \<lbrace>P\<rbrace>"
  by (wpsimp wp: dmo_mapM_x_wp_inv simp: cacheRangeOp_def)

lemma dmo_cleanCacheRange_PoU_respects [wp]:
  "do_machine_op (cleanCacheRange_PoU vstart vend pstart) \<lbrace>integrity aag X st\<rbrace>"
  by (wpsimp wp: dmo_cacheRangeOp_lift simp: cleanCacheRange_PoU_def cleanByVA_PoU_def)

lemma dmo_mapM_x_cleanCacheRange_PoU_integrity:
  "do_machine_op (mapM_x (\<lambda>x. cleanCacheRange_PoU (f x) (g x) (h x)) refs) \<lbrace>integrity aag X st\<rbrace>"
  by (wp dmo_mapM_x_wp_inv)

lemma init_arch_objects_integrity[Retype_AC_assms]:
  "\<lbrace>integrity aag X st and K (\<forall>x\<in>set refs. is_subject aag x)
                       and K (\<forall>ref \<in> set refs. is_aligned ref (obj_bits_api new_type obj_sz))\<rbrace>
   init_arch_objects new_type ptr num_objects obj_sz refs
   \<lbrace>\<lambda>_. integrity aag X st\<rbrace>"
  apply (rule hoare_gen_asm)+
  apply (cases new_type; simp add: init_arch_objects_def split del: if_split)
  apply (wpsimp wp: mapM_x_wp[OF _ subset_refl] copy_global_mappings_integrity
                    dmo_mapM_x_cleanCacheRange_PoU_integrity
              simp: obj_bits_api_def default_arch_object_def pd_bits_def pageBits_def)
  done

end


global_interpretation Retype_AC_1?: Retype_AC_1
proof goal_cases
  interpret Arch .
  case 1 show ?case
    by (unfold_locales; fact Retype_AC_assms)
qed


requalify_facts
  ARM_A.storeWord_respects

end
