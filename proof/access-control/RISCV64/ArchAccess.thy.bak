(*
 * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
 *
 * SPDX-License-Identifier: GPL-2.0-only
 *)

theory ArchAccess
imports Types
begin

context Arch begin global_naming ARM_A

subsection \<open>Arch-specific transformation of caps into authorities\<close>

definition vspace_cap_rights_to_auth :: "cap_rights \<Rightarrow> auth set" where
  "vspace_cap_rights_to_auth r \<equiv>
     (if AllowWrite \<in> r then {Write} else {})
   \<union> (if AllowRead \<in> r then {Read} else {})"

definition arch_cap_auth_conferred where
  "arch_cap_auth_conferred arch_cap \<equiv>
     (if is_PageTableCap arch_cap then vspace_cap_rights_to_auth (acap_rights arch_cap) else {Control})"


subsection \<open>Generating a policy from the current ASID distribution\<close>

term pte_ref

term pageBitsForSize

definition pde_ref2 where
  "pde_ref2 pde \<equiv> Some (0 :: obj_ref, 0 :: nat, {} :: auth set)"

term pte_ref


typ arch_kernel_obj
definition vs_refs_no_global_pts :: "kernel_object \<Rightarrow> (obj_ref \<times> obj_ref \<times> aa_type \<times> auth) set"
  where
  "vs_refs_no_global_pts \<equiv> \<lambda>ko. case ko of
     ArchObj (ASIDPool pool) \<Rightarrow> (\<lambda>(r,p). (p, ucast r, AASIDPool, Control)) ` graph_of pool
   | ArchObj (PageTable pt) \<Rightarrow> {}
   | _ \<Rightarrow> {}"

find_theorems name: vm_level

definition pte_ref where
  "pte_ref level pte \<equiv> case pte of
     PagePTE ppn atts rights
       \<Rightarrow> Some (pptr_from_pte (PagePTE ppn atts rights), pageBitsForSize (vmpage_size_of_level level), vspace_cap_rights_to_auth rights)
   | PageTablePTE ppn atts
       \<Rightarrow> Some (pptr_from_pte (PageTablePTE ppn atts), 0, {Control})
   | _ \<Rightarrow> None"

definition vs_refs_aux :: "vm_level \<Rightarrow> arch_kernel_obj \<Rightarrow> (obj_ref \<times> obj_ref \<times> aa_type \<times> auth) set"
  where
  "vs_refs_aux level \<equiv> \<lambda>ko. case ko of
     ASIDPool pool \<Rightarrow> (\<lambda>(r,p). (p, ucast r, AASIDPool, Control)) ` graph_of pool
   | PageTable pt \<Rightarrow>
       \<Union>(r,(p, sz, auth)) \<in> graph_of (pte_ref level o pt).
         (\<lambda>(p, a). (p, ucast r, APageTable, a)) ` (ptr_range p sz \<times> auth)
   | _ \<Rightarrow> {}"

definition vs_refs where
  "vs_refs x \<equiv> \<lambda>s. {x | x bot_level asid vref level p ao.
                          vs_lookup_table bot_level asid vref s = Some (level, p) \<and>
                          vref \<in> user_region \<and> aobjs_of s p = Some ao \<and> x \<in> vs_refs_aux level ao}"

term user_region
term valid_vspace_objs
term vs_lookup_table
typ vm_level
typ vmpage_size


end (*
\<comment> \<open>We exclude the global page tables from the authority graph. Alternatively, we could include them
    and add a wellformedness constraint to policies that requires that every label has the necessary
    authority to whichever label owns the global page tables, so that when a new page directory is
    created and references to the global page tables are added to it, no new authority is gained.
    Note: excluding the references to global page tables in this way brings in some ARM
          arch-specific VM knowledge here\<close>
definition vs_refs_no_global_pts :: "kernel_object \<Rightarrow> (obj_ref \<times> obj_ref \<times> aa_type \<times> auth) set"
  where
  "vs_refs_no_global_pts _ \<equiv> {}"

term vs_lookup_target
term riscv_asid_table
thm vs_lookup_table_def
thm Let_def
term "
let x = pptr_from_pte (PagePTE ppn atts rights) in
    P x"
typ vmpage_size
typ arch_cap

term pool_for_asid
term vs_lookup_table
term asid_pools_of

term valid_vspace_objs

lemma "data_at (vmpage_size_of_level 0) (ptrFromPAddr (addr_from_ppn ppn)) s"
thm data_at_def
thm a_type_def
apply (clarsimp simp: data_at_def vmpage_size_of_level_def obj_at_def a_type_def
 split: if_splits kernel_object.splits arch_kernel_obj.splits)

definition state_vrefs where
  "state_vrefs s = case_option {} vs_refs_no_global_pts o kheap s"
typ arch_kernel_obj
typ pte
term addr_from_pte
typ vmpage_size
thm ptrFromPAddr_def
thm pptr_from_pte_def
thm invs_def
typ vm_level

term vmpage_size_of_level
term pt_walk
term max_pt_level
term valid_pte
(*
fun pt_walk ::
  "vm_level \<Rightarrow> vm_level \<Rightarrow> obj_ref \<Rightarrow> vspace_ref \<Rightarrow> (obj_ref \<rightharpoonup> pte) \<Rightarrow> (vm_level \<times> obj_ref) option"
  where
  "pt_walk max_pt_level 0 pt_ptr vptr
*)
term "pt_walk max_pt_level bot_level top_level_pt vptr \<circ> ptes_of"
term pt_index
term pt_slot_offset

definition pt_bits_left :: "vm_level \<Rightarrow> nat"
  where
  "pt_bits_left level = ptTranslationBits * size level + pageBits"

definition pt_index :: "vm_level \<Rightarrow> vspace_ref \<Rightarrow> machine_word"
  where
  "pt_index level vptr \<equiv> (vptr >> pt_bits_left level) && mask ptTranslationBits"

definition pt_slot_offset :: "vm_level \<Rightarrow> obj_ref \<Rightarrow> vspace_ref \<Rightarrow> obj_ref"
  where
  "pt_slot_offset level pt_ptr vptr = pt_ptr + (pt_index level vptr << pte_bits)"


definition asid_pool_level :: vm_level
  where
  "asid_pool_level = maxBound"

lemma "typ_at (AArch APageTable) (ptrFromPAddr (addr_from_ppn ppn)) s \<Longrightarrow> P"
apply (clarsimp simp: obj_at_def)
oops

lemma pageBitsForSize_pt_bits_left:
  "pageBitsForSize sz = pt_bits_left (level_of_sz sz)"
  by (cases sz; simp add: level_of_sz_def pt_bits_left_def pageBitsForSize_def)

text \<open>
  The number of levels over all virtual memory tables.
  For RISC-V, we have three page table levels plus the ASID pool level.

  The top level (with the highest number) contains ASID pools, the next levels contain the
  top-level page tables, and level 1 page tables. The bottom-level page tables (level 0)
  contains only InvalidPTEs or PagePTEs.
\<close>

find_consts vm_level

datatype pte =
    InvalidPTE
  | PagePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes) (pte_rights : vm_rights)
  | PageTablePTE (pte_ppn : pte_ppn) (pte_attr : vm_attributes)

term "ArchObj (ASIDPool pool)"
(* aag caps asid_tab vrefs *)

definition valid_vspace_objs :: "'z::state_ext state \<Rightarrow> bool" where
  "valid_vspace_objs \<equiv> \<lambda>s.
     \<forall>bot_level asid vref level p ao.
       vs_lookup_table bot_level asid vref s = Some (level, p)
       \<longrightarrow> vref \<in> user_region
       \<longrightarrow> aobjs_of s p = Some ao
       \<longrightarrow> case ao of
       \<longrightarrow> valid_vspace_obj level ao s"



end (*

(* FIXME ryanb *)
context pspace_update_eq begin interpretation Arch .

lemma state_vrefs[iff]: "state_vrefs (f s) = state_vrefs s"
  by (simp add: state_vrefs_def pspace)

end

context Arch begin

primrec aobj_ref' where
  "aobj_ref' (ASIDPoolCap p as) = {p}"
| "aobj_ref' ASIDControlCap = {}"
| "aobj_ref' (FrameCap ref cR sz dev as) = ptr_range ref (pageBitsForSize sz)"
| "aobj_ref' (PageTableCap x as3) = {x}"

fun acap_asid' :: "arch_cap \<Rightarrow> asid set" where
  "acap_asid' (FrameCap _ _ _ _ mapping) = fst ` set_option mapping"
| "acap_asid' (PageTableCap _ mapping) = fst ` set_option mapping"
| "acap_asid' (ASIDPoolCap _ asid)
     = {x. asid_high_bits_of x = asid_high_bits_of asid \<and> x \<noteq> 0}"
| "acap_asid' ASIDControlCap = UNIV"

inductive_set state_asids_to_policy_aux for aag caps asid_tab vrefs where
  sata_asid:
    "\<lbrakk> caps ptr = Some (ArchObjectCap acap); asid \<in> acap_asid' acap \<rbrakk>
       \<Longrightarrow> (pasObjectAbs aag (fst ptr), Control, pasASIDAbs aag asid)
             \<in> state_asids_to_policy_aux aag caps asid_tab vrefs"
| sata_asid_lookup:
    "\<lbrakk> asid_tab (asid_high_bits_of asid) = Some poolptr;
       (pdptr, ucast (asid && mask asid_low_bits), AASIDPool, a) \<in> vrefs poolptr \<rbrakk>
       \<Longrightarrow> (pasASIDAbs aag asid, a, pasObjectAbs aag pdptr)
             \<in> state_asids_to_policy_aux aag caps asid_tab vrefs"
| sata_asidpool:
    "\<lbrakk> asid_tab (asid_high_bits_of asid) = Some poolptr; asid \<noteq> 0 \<rbrakk>
       \<Longrightarrow> (pasObjectAbs aag poolptr, AAuth ASIDPoolMapsASID, pasASIDAbs aag asid)
             \<in> state_asids_to_policy_aux aag caps asid_tab vrefs"

definition
  "state_asids_to_policy_arch aag caps astate vrefs \<equiv>
     state_asids_to_policy_aux aag caps (riscv_asid_table astate)
                               (vrefs :: 64 word \<Rightarrow> (64 word \<times> 64 word \<times> aa_type \<times> auth) set)"
declare state_asids_to_policy_arch_def[simp]

section \<open>Arch-specific integrity definition\<close>

subsection \<open>How ASIDs can change\<close>

definition integrity_asids_aux ::
  "'a PAS \<Rightarrow> 'a set \<Rightarrow> asid \<Rightarrow> obj_ref option \<Rightarrow> obj_ref option \<Rightarrow> bool" where
  "integrity_asids_aux aag subjects asid pp_opt pp_opt' \<equiv>
     pp_opt = pp_opt' \<or> (\<forall>asid'. asid' \<noteq> 0 \<and> asid_high_bits_of asid' = asid_high_bits_of asid
                                 \<longrightarrow> pasASIDAbs aag asid' \<in> subjects)"

definition integrity_asids ::
  "'a PAS \<Rightarrow> 'a set \<Rightarrow> asid \<Rightarrow> 'y::state_ext state \<Rightarrow> 'z:: state_ext state  \<Rightarrow> bool" where
  "integrity_asids aag subjects x s s' \<equiv>
   integrity_asids_aux aag subjects x (asid_table s  (asid_high_bits_of x))
                                      (asid_table s' (asid_high_bits_of x))"

lemma integrity_asids_trans_state_l[simp]:
  "integrity_asids aag subjects x (trans_state f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_trans_state_r[simp]:
  "integrity_asids aag subjects x st (trans_state f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_cur_thread_update_l[simp]:
  "integrity_asids aag subjects x (cur_thread_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_cur_thread_update_r[simp]:
  "integrity_asids aag subjects x st (cur_thread_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_kheap_update_l[simp]:
  "integrity_asids aag subjects x (kheap_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_kheap_update_r[simp]:
  "integrity_asids aag subjects x st (kheap_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_machine_state_update_l[simp]:
  "integrity_asids aag subjects x (machine_state_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_machine_state_update_r[simp]:
  "integrity_asids aag subjects x st (machine_state_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_cdt_update_l[simp]:
  "integrity_asids aag subjects x (cdt_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_cdt_update_r[simp]:
  "integrity_asids aag subjects x st (cdt_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_is_original_cap_update_l[simp]:
  "integrity_asids aag subjects x (is_original_cap_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_is_original_cap_update_r[simp]:
  "integrity_asids aag subjects x st (is_original_cap_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_interrupt_states_update_l[simp]:
  "integrity_asids aag subjects x (interrupt_states_update f st) s =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

lemma integrity_asids_interrupt_states_update_r[simp]:
  "integrity_asids aag subjects x st (interrupt_states_update f s) =
   integrity_asids aag subjects x st s"
  by (simp add: integrity_asids_def)

(* FIXME ryanb - is there a locale which could better handle this? *)
lemmas integrity_asids_updates =
  integrity_asids_trans_state_l
  integrity_asids_trans_state_r
  integrity_asids_cur_thread_update_l
  integrity_asids_cur_thread_update_r
  integrity_asids_kheap_update_l
  integrity_asids_kheap_update_r
  integrity_asids_machine_state_update_l
  integrity_asids_machine_state_update_r
  integrity_asids_cdt_update_l
  integrity_asids_cdt_update_r
  integrity_asids_is_original_cap_update_l
  integrity_asids_is_original_cap_update_r
  integrity_asids_interrupt_states_update_l
  integrity_asids_interrupt_states_update_r


(* FIXME ryanb *)
subsection \<open>Misc definitions\<close>

fun ctxt_IP_update where
  "ctxt_IP_update (UserContext ctxt) = UserContext (ctxt(NextIP := ctxt FaultIP))"

abbreviation arch_IP_update where
  "arch_IP_update arch \<equiv> arch_tcb_context_set (ctxt_IP_update (arch_tcb_context_get arch)) arch"

definition asid_pool_integrity ::
  "'a set \<Rightarrow> 'a PAS \<Rightarrow> (asid_low_index \<rightharpoonup> obj_ref) \<Rightarrow> (asid_low_index \<rightharpoonup> obj_ref) \<Rightarrow> bool" where
  "asid_pool_integrity subjects aag pool pool' \<equiv>
     \<forall>x. pool' x \<noteq> pool x
         \<longrightarrow> pool' x = None \<and> aag_subjects_have_auth_to subjects aag Control (the (pool x))"

inductive arch_integrity_obj_atomic ::
   "'a PAS \<Rightarrow> 'a set \<Rightarrow> 'a \<Rightarrow> arch_kernel_obj \<Rightarrow> arch_kernel_obj \<Rightarrow> bool"
  for aag subjects l ao ao' where
  arch_troa_asidpool_clear:
    "\<lbrakk> ao = ASIDPool pool; ao' = ASIDPool pool';
       asid_pool_integrity subjects aag pool pool' \<rbrakk>
       \<Longrightarrow> arch_integrity_obj_atomic aag subjects l ao ao'"

inductive arch_integrity_obj_alt ::
   "'a PAS \<Rightarrow> 'a set \<Rightarrow> 'a \<Rightarrow> arch_kernel_obj \<Rightarrow> arch_kernel_obj \<Rightarrow> bool"
  for aag subjects l' ao ao' where
  arch_tro_alt_asidpool_clear:
    "\<lbrakk> ao = ASIDPool pool; ao' = ASIDPool pool';
       asid_pool_integrity subjects aag pool pool'\<rbrakk>
       \<Longrightarrow> arch_integrity_obj_alt aag subjects l' ao ao'"

definition auth_ipc_buffers :: "'z::state_ext state \<Rightarrow> obj_ref \<Rightarrow> obj_ref set" where
  "auth_ipc_buffers s \<equiv> \<lambda>p. case (get_tcb p s) of
     None \<Rightarrow> {}
   | Some tcb \<Rightarrow>
     (case tcb_ipcframe tcb of
        ArchObjectCap (FrameCap p' R vms False _) \<Rightarrow>
          if AllowWrite \<in> R
          then (ptr_range (p' + (tcb_ipc_buffer tcb && mask (pageBitsForSize vms))) msg_align_bits)
          else {}
      | _ \<Rightarrow> {})"

end


context begin interpretation Arch .

requalify_consts
  aobj_ref'
  acap_asid'
  state_vrefs
  state_asids_to_policy_arch
  integrity_asids
  ctxt_IP_update
  arch_IP_update
  arch_cap_auth_conferred
  arch_integrity_obj_atomic
  arch_integrity_obj_alt
  auth_ipc_buffers

requalify_facts
  integrity_asids_updates

end

declare integrity_asids_updates[simp]

end
